// This will enable all verbose messages generated by this file
console.verbose.filterObjects.push("components.cards.js");

// The "Cards" directive creates a container that holds the "Card" objects.
//  This will generally be injected directly into a workspace.
irulanclient.directive('cards', function directive$cards() {
  console.verbose("cards directive")
  return {
    restrict: 'E',
    transclude: true,
    template:
      '<div id="cardsworkspace">'+
      '  <div ng-repeat="(name, card) in cards">'+
      '    <card ng-cardname="{{name}}">{{name}}</card>'+
      '    <ng-transclude></ng-transclude>'+
      '  </div>'+
      '</div>',
  }
})

irulanclient.directive('card', ['$filter', '$timeout', '$compile', function directive$card($filter, $timeout, $compile) {
  return {
    restrict: 'E',
    link: function directive$card$link($scope, $element, $attrs, controller, $transclude) {
      console.verbose('inject card!');
      if (!$transclude) {
        throw minErr('ngTransclude')('orphan',
          'Illegal use of ngTransclude directive in the template! ' +
          'No parent directive that requires a transclusion found. ' +
          'Element: {0}',
          startingTag($element)
        );
      }

      var card = $scope.cards[$attrs['ngCardname']];
      //console.verbose($filter('cardRenderer')(card));
      //console.verbose($element)
      //$element[0].innerHTML = $filter('cardRenderer')(card);

      var context = {
        card: card,
        cardname: $attrs['ngCardname'],
        scope: $scope,
        element: $element,
        attrs: $attrs,
        filter: $filter,
        controller: controller,
        transclude: $transclude
      }
      $scope.$watch(
        (function directive$card$watch$monitor() {
          return JSON.stringify($scope.cards[context.cardname]);
        }).bind(context),
        (function directive$card$watch$callback() {
          //window.setTimeout(
          $timeout((function directive$card$watch$callback$timeout() {
            console.verbose("card update detected");
            console.verbose(context);
            console.verbose(this);

            // If we were to simply push the new HTML content into
            //  element[0].innerHTML then any directives it contains (e.g.
            //  "<warning>some text</warning>") would not get processed.
            //  Instead the new content is passed back through the compiler for
            //  further AngularJS processing.  Talking directly to the DOM
            //  (.innerHTML attribute) hides the update from AngularJS.
            var template = $filter('cardRenderer')(context.card);
            var linkFunction = $compile(template);
            var content = linkFunction(context.scope);
            context.element.empty();
            context.element.append(content);

          }).bind(context), 1, true);
        }).bind(context)
      )
    }
  }
}])

// Empty template for a "Card" object.  TODO: This should probably become a
//  'prototype' but I don't know how to do that yet
irulanclient.factory('Card', function() {
  function Card() {
    // Do I need anything here?
  }

  // The object.get() function is called when the object is created.  This will
  //  Generally be used to fetch some data from a server and turn it into
  //  something that can be passed to a SourceRenderer
  Card.get = function(options, callback) {
    // This generic item has an empty get function.

    var context = [];
    context.thisCard = new Card;
    context.thisCard.name = options.name;
    context.thisCard.sourceFormat = "html";
    context.thisCard.content = "<b>Text for card body goes here!</b>";
    context.thisCard.title = "Untitled Card";
    context.callback = callback;

    return context.thisCard;
  }
  return (Card);
})

// This is a generic component so it doesn't create it's own /something
//  namespace (hence it being set to 'null' below).  We do need to register
//  Factory and Workspace handlers though so that other components that use
//  cards can inherit them.
irulanclient.run(['WorkspaceProviders', 'Card', 'Cards', function(WorkspaceProviders, Card, Cards) {
  // How can I push the factory?
  WorkspaceProviders.push({
    namespace: null,
    factory: Card,
    workspace: Cards,
  });
}]);

irulanclient.service('Cards', ['Card', 'Workspaces', 'WorkspaceProviders', '$resource', function service$cards(Cards, Workspaces, WorkspaceProviders, $resource){
  //this.Card = Card
  this.cards = {};
  this.Workspaces = Workspaces;

  console.verbose("Cards: WorkspaceProviders: " + JSON.stringify(WorkspaceProviders));

  this.get = function service$cards$get(options, callback) {
    for (index in WorkspaceProviders) {
      WorkspaceProvider = WorkspaceProviders[index];
      //console.log(CardNamespaceProvider);
      if (WorkspaceProvider.namespace) {
        if (options.name.substring(0, WorkspaceProvider.namespace.length) == WorkspaceProvider.namespace) {
          console.verbose(WorkspaceProvider.namespace + ' can handle the request for ' + options.name);
          console.verbose(WorkspaceProvider);
          var newCard = WorkspaceProvider.factory;
          return newCard.get(options, callback)
        }
      }
    }
    //TODO: work out what will happen if this happens
    return false;
  }

  this.show = function service$cards$show(options, scope, callback) {
    console.verbose("Show Cards scope:")
    console.verbose(scope);

    //TODO: unhide the cardsworkspace div
    for (var index in WorkspaceProviders) {
      if (WorkspaceProviders[index].namespace) {
        console.verbose(WorkspaceProviders[index].namespace + ' ' + WorkspaceProvider.namespace);
        if ((WorkspaceProviders[index].namespace != WorkspaceProvider.namespace) || (WorkspaceProviders[index].namespace == null)) {
          console.verbose(WorkspaceProviders[index]);
          if (WorkspaceProviders[index].hide) {
            WorkspaceProviders[index].hide();
          }
        }
      }
    }

    //TODO: I think that if we specifically target the correct
    //  NameSpaceProvider's own array of cards then we can have multiple apps
    //  using the common "Cards" provider with the actual cards for that
    //  namespace shown.
    scope.cards = WorkspaceProvider.cards;

    //$scope.cards[options.name] = this.get(options, function service$cards$show$callback() {
    //  console.verbose("Show cards callback");
    //  callback();
    //});
  }

  this.hide = function() {
    console.verbose("hide cards");
  }

  this.new = function() {
    return new Card;
  }
}])

// This filter takes a "card" object and runs it through the appropraite
//  functions to convert it from Text/HTML/Markdown/Wiki Syntax, etc to HTML
irulanclient.filter('cardRenderer', ['$filter', 'SourceRenderers', 'Cards', function ($filter, SourceRenderers, Cards) {
  return function filter$cardRenderer(card) {
    // The provided card might actually be just a pointer (alias) to another
    //  card
    if (card.alias) {
      //TODO
    }

    if (card.sourceFormat) {
      if (card.sourceFormat == null) {
        return card.content
      }

      var rendered = false;
      for (index in SourceRenderers) {
        SourceRenderer = SourceRenderers[index];
        if (SourceRenderer.sourceFormat == card.sourceFormat) {
          console.verbose('Using ' + SourceRenderer.name);
          card.renderedHtml = $filter(SourceRenderer.name)(card);
          rendered = true;
        }
      }
      if (!rendered) {
        card.renderedHtml = "I don't know how to render this card: " + JSON.stringify(card);
      }

      var html = '<div style="margin-left: 1em; margin-right: 1em;" class="panel panel-primary">';
      html += '<md-card class="md-whiteframe-9dp">';
      html += '      <h1>' + card.title + '</h1>';
      //html += '<md-fab-toolbar class="md-small-fab-toolbar" md-open="demo.isOpen" count="demo.count" md-direction="left" old-md-theme="docs-dark">';
      //html += '  <md-fab-trigger class="align-with-text">';
      //html += '    <md-button aria-label="menu" class="md-fab md-hue-2 md-fab-small" old-style="width: 35px; height: 35px;">';
      //html += '      <md-icon><i class="zmdi zmdi-menu zmdi-hc-lg"></i></md-icon>';
      //html += '    </md-button>';
      //html += '  </md-fab-trigger>';
      //html += '  <md-toolbar>';
      //html += '    <md-fab-actions class="md-toolbar-tools">';
      //html += '      <md-button aria-label="comment" class="md-icon-button">';
      //html += '        <md-icon><i class="zmdi zmdi-edit zmdi-hc-lg"></i></md-icon>';
      //html += '      </md-button>';
      //html += '      <md-button aria-label="label" class="md-icon-button">';
      //html += '        <md-icon><i class="zmdi zmdi-label zmdi-hc-lg"></i></md-icon>';
      //html += '      </md-button>';
      //html += '      <md-button aria-label="photo" class="md-icon-button">';
      //html += '        <md-icon><i class="zmdi zmdi-code zmdi-hc-lg"></i></md-icon>';
      //html += '      </md-button>';
      //html += '    </md-fab-actions>';
      //html += '  </md-toolbar>';
      //html += '</md-fab-toolbar>';

    //  html += '  </md-card-header>';

      html += '  <md-card-content>' + card.renderedHtml + '</md-card-content>';
      html += '</md-card>';
      html += '</div>';
      return html;
    }
    else {
      console.verbose("Rendering card raw since it has no sourceFormat")
      return card
    }
  }
}])
