// If the console.verbose.js script hasn't been loaded we create some dummy
//  objects to prevent errors being generated
if (typeof console.verbose !== 'function') {
  console.verbose = function() {
    return true;
  }
}
console.verbose.filterObjects = [];
console.verbose.filterObjects.enabled = true;

// uncomment the following to enable verbose logging of various functions
//console.verbose.filterObjects.push(/^config/);
//console.verbose.filterObjects.push(/^directive/);
//console.verbose.filterObjects.push(/^service/);
//console.verbose.filterObjects.push(/^filter/);

// This will enable all verbose messages generated by this file
console.verbose.filterObjects.push("irulanclient.js");

var irulanclient = angular.module('IrulanClient', ['ngResource', 'ngMaterial', 'ngRoute'])
  .config(function config$locationProvider($locationProvider) {
    $locationProvider.html5Mode(true).hashPrefix('!');
    console.verbose('$locationProvider');
    console.verbose($locationProvider);
  })

  .config(function config$mdThemingProvider($mdThemingProvider) {
    // Configure a dark theme with primary foreground yellow
    var testTheme = $mdThemingProvider.theme('docs-dark', 'default')
      .primaryPalette('blue-grey')
      .dark();
    console.verbose(testTheme);
    console.verbose($mdThemingProvider);
    console.verbose(testTheme.colors.primary.name);
    console.verbose($mdThemingProvider._PALETTES[testTheme.colors.primary.name]['100']);
  })

  .run(['$rootScope', function($rootScope) {
    //$rootScope.$on('$locationChangeStart', function (event, newUrl, oldUrl) {
    //  console.verbose('locationChangeStart');
    //})
  }])

  .config(function($provide, $routeProvider, $locationProvider) {
    $provide.factory('$routeProvider', function() {
      return $routeProvider;
    })

    //$locationProvider.html5Mode(true);
  })

  // An array of filter names and the "sourceTypes" they can handle.  For
  //  example:
  //    {
  //      sourceFormat: 'md',
  //      name: 'markdownRenderer'
  //    }
  .value('SourceRenderers', Array())

  // An array of installed "apps" and their capibilities
  .value('Apps', Array())

  // An array of Page Namespaces and the factories that can create them.  Not yet finished.
  .value('WorkspaceProviders', Array())

  .service('Workspaces', ['WorkspaceProviders', function WorkspacesService(WorkspaceProviders){
    var defaultScope = null;

    /**
     * Switches between active workspaces (which usually means applications)
     *
     * @this {Workspaces}
     * @param {options} - Associative array of options
     * @param {$scope} -
     * @param {callback} - callback function on success/failure
     */
    this.switch = function(options, $scope, callback) {
      // If no scope was specified (i.e. 'null') we will pass the defaultScope
      //  that was configured during controller startup.
      if ($scope == null) {
        $scope = this.defaultScope;
      }

      for (index in WorkspaceProviders) {
        WorkspaceProvider = WorkspaceProviders[index];
        if (WorkspaceProvider.namespace) {
          console.verbose(WorkspaceProvider);
          if (options.name.substring(0, WorkspaceProvider.namespace.length) == WorkspaceProvider.namespace) {
            console.verbose(WorkspaceProvider.namespace + ' can handle the request for ' + options.name);
            WorkspaceProvider.workspace.show(options, $scope, callback);
          }
          else {
            console.verbose(options.name.substring(0, WorkspaceProvider.namespace.length) + ' != ' + WorkspaceProvider.namespace);
          }
        }
      }
    }
  }])

  //.run(['Apps', function(Apps) {
  //  Apps.push({
  //    name: 'irulanlauncherpage',
  //    enabled: true,
  //    launcher: {
  //      enabled: false,
  //    },
  //    // Each application will have the ability to specify some colors that will
  //    //  be applied to the global CSS (e.g. Navbar color) so the user has a clear
  //    //  indication that they have move to a new app
  //    theme: {
  //      colors: {
  //        color_1: '#FFFFFF',
  //        color_2: '#000000',
  //      },
  //      // The application can also have it's own background image (wallpaper)
  //      background: {
  //        image: 'some url',
  //        color: '#FFFFFF',
  //      },
  //    }
  //  })
  //}])

  // Create and register a simple text format SourceRenderer
  .filter('textRenderer', function filter$markdownRenderer() {
    return function(page) {
      return page.content;
    }
  })
  // Register the markdownRenderer for handling any data marked as "md"
  .run(['SourceRenderers', function(PageRenderers) {
    PageRenderers.push({
      sourceFormat: 'text',
      name: 'textRenderer'
    });
  }])

  // Create and register a simple HTML format SourceRenderer
  .filter('htmlRenderer', function filter$markdownRenderer() {
    return function(page) {
      return page.content;
    }
  })
  // Register the markdownRenderer for handling any data marked as "md"
  .run(['SourceRenderers', function(PageRenderers) {
    PageRenderers.push({
      sourceFormat: 'html',
      name: 'htmlRenderer'
    });
  }])

  // This controller controls the startup state of the application
  .controller('WorkspacesController', ['$scope', '$location', 'Workspaces', 'Apps', function WorkspacesController($scope, $location, Workspaces, Apps) {
    console.verbose($scope);

    //irulanclient.show_launcher = function() {
    //  console.log("show_launcher");
    //  console.log($scope);
    //
    //  $scope.$broadcast("show_launcher", {})
    //};

    //TODO: Move this to a .value? item
    $scope.homePage = 'wiki/home';

    console.verbose($location.path());

    Workspaces.defaultScope = $scope;

    //var newpage = Pages.new();
    //$scope.pages['start'] = newpage;

    //$scope.pages['wiki/home'] = Pages.get({ name: 'wiki/home' }, function(page) {
    //  console.log(page);
    //  //$scope.pages['wikipage:home'] = page;
    //})

    // Whenever a relative link is clicked AngularJS updates the browser's
    //  address bar and broadcasts a "$locationChangeStart" event.  We need to
    //  listen for this event so we know when to load a new page.  This event
    //  also fires on startup so we use it to load the initial page.
    $scope.$on('$locationChangeStart', function(event, next, current) {
      console.verbose(Workspaces);
      var newpage = $location.path();
      newpage = newpage.replace(/^\//, "");
      if (newpage.length < 1) {
        newpage = $scope.homePage;
      }

      Workspaces.switch({ name: newpage }, $scope, function() {
        console.verbose("do I need a callbeck function?");
      })
    });
  }])

  /**
   * This function sets up the initial conditions of the "workspace" (the area
   *  of the page where apps are rendered) as well as initialising some global
   *  objects (e.g. $route).
   *
   * @todo Port the $locationChangeStart stuff from the above old controller
   *        into this one
   * @todo Set the initial page url if none was specified (e.g. /wiki/home)
   */
  .controller('WorkspaceController', ['WorkspaceProviders', 'Workspaces', '$routeProvider', '$scope', '$route', '$routeParams', '$location', function WorkspaceController(WorkspaceProviders, Workspaces, $routeProvider, $scope, $route, $routeParams, $location) {
    console.verbose("WorkspaceController:")
    console.verbose(this);
    console.verbose(Workspaces);
    console.verbose($routeProvider);
    //console.verbose($routeProvider);
    this.WorkspaceProviders = WorkspaceProviders;

    // Set the home page
    this.homePage = 'wiki/home';

    // Add the event hook that captures link clicks within this controller's
    //  scope and passes them the the Workspoaces.Switch function
    $scope.$on('$locationChangeStart', (function(event, next, current) {
      console.verbose("$scope.$locationChangeStart");
      //console.verbose(Workspaces);
      var newpage = $location.path();
      newpage = newpage.replace(/^\//, "");
      if (newpage.length < 1) {
        newpage = this.homePage;
      }
      console.log(newpage)

      Workspaces.switch({ name: newpage }, $scope, function() {
        console.verbose("do I need a callback function?");
      })
    }).bind(this));
  }])

  /**
   * Dynamically inject an element into the <workspaces></workspaces> element
   *  for each of the registered WorkspaceProviders.  The WorkspaceProvider
   *  should have a "directive" property which will be injected as
   *  "<directive></directive>".
   *
   * @this {WorkspaceController}
   */
  .directive('workspaces', ['WorkspaceProviders', '$timeout', '$compile', function directive$workspaces(WorkspaceProviders, $timeout, $compile) {
    this.WorkspaceProviders = WorkspaceProviders;

    /**
     * Create the simple <direcitve></directive> HTML content that will be later
     *  processed and injected into the DOM
     *
     * @this {WorkspaceController}
     */
    this.getTemplate = function() {
      var template = '';
      for (var index in this.WorkspaceProviders) {
        var WorkspaceProvider = this.WorkspaceProviders[index];
        if (WorkspaceProvider.directive) {
          template = template + "<" + WorkspaceProvider.directive + "></" + WorkspaceProvider.directive + ">"
        }
      }
      return template;
    }
    return {
      restrict: 'E',
      transclude: true,

      /**
       * The "link" function is called when AngularJS is ready to update
       *  elements in the DOM.  We don't take any direct action at this point,
       *  instead we start a watcher.
       */
      link: function directive$workspaces$link($scope, $element, $attrs, controller, $transclude) {
        /**
         * Start a watcher.  Every time AngularJS thinks there's a reason to
         *  check to make sure the DOM is properly synced with it's background
         *  data, it calls the first function.  It expects a simple value that
         *  it can compare to the last time it did this check so it can detect
         *  changes.
         *
         * @this {WorkspaceController}
         */
        $scope.$watch((function directive$workspaces$watch$monitor() {
          return this.getTemplate();
        }).bind(this),

        /**
         * This function is called if the previous function returned a different
         *  value than was expected.  Again, we don't act directly at this
         *  point, we start a 1ms timeout which won't be triggered until after
         *  the current AngularJS background processing is completed (even if
         *  that takes more than 1ms)
         *
         * @this {WorkspaceController}
         */
        (function directive$workspaces$watch$callback() {
          /**
          * We use the WorkspaceController.getTemplate() function again and we
          *  run the result through the $compiler so that the directives it
          *  contains are processed (if we injected the template directly the
          *  directives would be injected as is and never processed as
          *  directives).  We then inject the result into the DOM.
          *
          * @this {WorkspaceController}
          */
          $timeout((function directive$workspaces$watch$callback$timeout() {
            console.verbose("workspaces update detected");
            var linkFunction = $compile(this.getTemplate());
            var content = linkFunction($scope);
            $element.empty();
            $element.append(content);
          }).bind(this), 1, true)
        }).bind(this));
      }
    }
  }])

  .controller('AppsMenu', ['$mdDialog', 'Apps', '$scope', function AppsMenuController($mdDialog, Apps, $scope) {
    // Turn on verbose console logging of this component
    //console.verbose.filterObjects.push(/AppsMenuController/);

    $scope.Apps = Apps
    this.openMenu = function($mdOpenMenu, ev) {
      originatorEv = ev;
      $mdOpenMenu(ev);
    };
    this.menuItemClick = function (ev) {
      // If the user clicked the area around the text the event will have been
      //  generated by the "button" element.
      var targetElement = ev.target;

      // If the actual text label was clicked however the "span" element will
      //  have generated the event.  We need the button though, which is the
      //  span's parent.
      if (ev.target.nodeName.match(/SPAN/i)) {
        targetElement = ev.target.parentNode;
      }

      // Maybe we still don't have the object the way we need it.  Let's not
      //  assume and proceed with caution.
      appName = '';
      try {
        appName = targetElement.attributes['irulan-appname'].value;
      }
      catch (e) {
        console.error("Unable to find the irulan-appname attribute for this menu item");
        return false;
      }
      //console.debug.call(this, appName);
      console.verbose(appName);

      // We have the app name, let's fine the relevant object in the Apps object
      var App = null;
      for (var index in Apps) {
        try {
          if (Apps[index].name == appName) {
            App = Apps[index];
          }
        }
        catch (e) {
          console.error("One or more of the objects in the Apps array might be broken or missing a 'name' attribute.  %O", Apps);
        }
      }

      // If we somehow didn't find the selected app...
      if (App == null) {
        console.error("The user somehow selected an app that doesn't exist in the App array: " + appName);
        return false;
      }
      //console.log(App)

      // Trigger the "click" event specified for the App, if defined.
      if (App.launcher.click) {
        try {
          App.launcher.click(ev);
        }
        catch (e) {
          console.error("Calling the 'click' function for the '" + appName + "' app failed.  " + e.message);
        }
      }
    }
  }])

  .controller('AccountsMenu', ['$mdDialog', function AccountsMenuController($mdDialog) {
    this.openMenu = function($mdOpenMenu, ev) {
      originatorEv = ev;
      $mdOpenMenu(ev);
    };
  }]);
