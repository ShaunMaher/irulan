"use strict";
var fs = require("fs");
var path = require("path");
const dns = require('dns');
module.app = {};

var ping = false;
try {
  var ping = require('net-ping');
}
catch (err) {
  console.log("Cannot use net-ping to perform ICMP checks.  On linux systems try \"sudo setcap 'cap_net_raw=+ep' $(env node)\" or \"sudo setcap 'cap_net_raw=+ep' $(env nodejs)\"");
  var ping = false;
}

// Storing some properties in WeakMaps hides them from things like
//  console.log(LXCHostError).
//  http://www.2ality.com/2016/01/private-data-classes.html
let _timeStamp = new WeakMap();
var LXCHostError = class extends Error {
  constructor(message) {
    super(message);

    _timeStamp.set(this, Date.now());
  }
  //toString() {
  //  return super.toString();
  //}
  get valueOf() {
    return "Error: " + this.message
  }
  get detail() {
    return this.timeStamp.toDateString() + "Error: " + this.message
  }
}

// Use a WeakMap to keep the "net-ping" object hidden within the LXCHost class.
let _ping = new WeakMap();
var LXCHost = class {
  constructor (name) {
    this.IPs = [];
    this.name = name;
    this.errors = [];
    this.lastIcmpContact = '';
    this.lastLXDApiContact = '';
    this.lastIrulanApiContact = '';
    this.containers = new LXCContainers();

    // The net-ping module will fail to load if we are not running as root or
    //  with CAP_NET_RAW.  Try to handle this gracefully and intelligently.
    if (ping) {
      _ping.set(this, false);
      try {
        _ping.set(this, ping.createSession().on('error', function(err) {
          console.log("Error setting up net-ping: ", err);
          this.ping = false;
        }));
      }
      catch (err) {
        if (err.message.match(/Operation not permitted/)) {
          console.log("Cannot use net-ping to perform ICMP checks.  On linux systems try \"sudo setcap 'cap_net_raw=+ep' $(env node)\" or \"sudo setcap 'cap_net_raw=+ep' $(env nodejs)\"");
        }
        else {
          console.log("Cannot use net-ping to perform ICMP checks.", err);
        }
        _ping.set(this, false);
      }
    }
  }

  get valueOf() {
    // Use the valueOf getter function to trigger a cleanup of the "errors"
    //  array so it doesn't grow forever.
    while (this.errors.length > 10) {
      this.errors.shift();
    }
  }

  LXDApiPing(callback) {

  }
  IrulanApiPing(callback) {

  }
  IcmpPing(callback) {
    this._getIps();
    if (_ping.get(this)) {
      if (this.IPs.length > 0) {
        for (let ip of this.IPs) {
          _ping.get(this).pingHost(ip.value, (function(err, target) {
            if (err) {
              this.errors.push(new LXCHostError("IcmpPing(" + target +"): " + err.message));
            } else {
              console.log (target + ": Alive");
              this.lastIcmpContact = (new Date).now();
            }
          }).bind(this));
        }
      }
      else {
        this.errors.push(new LXCHostError("IcmpPing(): No known IPs for this host."));
      }
    }
    else {
      this.errors.push(new LXCHostError("IcmpPing(): Cannot use net-ping to perform ICMP checks."));
    }
  }

  _getIps() {
    dns.lookup(this.name, {all: true}, (function(err, addresses) {
      if (err) {
        this.errors.push(new LXCHostError("_getIps(): " + err.message));
        return;
      }
      console.log("Addresses: ", addresses)
      for (let index in addresses) {
        for (let ip in this.IPs) {
          if (this.IPs[ip]['value'] == addresses[index].address) {
            this.IPs.splice(ip, 1);
          }
        }

        this.IPs.push({'value': addresses[index].address, 'fromName': this.name, 'family': addresses[index].family, 'lookupTime': Date.now()});
      }
    }).bind(this));
  }
}

var LXCHosts = class {
  constructor() {
    this.hosts = {}
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: (function() {
        if (index < Object.keys(this.hosts).length) {
          index++;
          return { value: this.hosts[(Object.keys(this.hosts))[index - 1]] };
        } else {
          return { done: true };
        }
      }).bind(this)
    }
  }
  add(_LXCHost) {
    if (_LXCHost instanceof LXCHost) {
      this.hosts[_LXCHost.name] = _LXCHost;
      return true;
    }
    else {
      console.log("Not a LXCHost object");
    }
  }
}
//LXCHosts.prototype.toString = function(){return JSON.stringify(this.hosts)};
//LXCHosts.prototype.valueOf = function(){return this.hosts};

function LXCContainer(name) {
  this.name = name;
  this.IPs = {};
  this.IPs.IPv4 = {};
  this.IPs.IPv6 = {};
  this.Running = false;
}

function LXCContainers() {
  this.containers = {};
  this.valueOf = function() { return this.containers };
  this.toString = function() { return JSON.stringify(this.containers) }
}

var LXDManagementServer = class {
  constructor (_app, router) {
    console.log("LXDManagementServer starting up.");

    // If an "_app" object was passed, use it.  Otherwise create a new empty
    //  object
    if (_app) {
      this.app = module.app = _app;
    }
    else {
      this.app = {};
    }

    // Load the localStorage module if there isn't one built in and "_app"
    //  didn't provide one.
    if (typeof this.app.localStorage === "undefined" || this.app.localStorage === null) {
      if (typeof localStorage === "undefined" || localStorage === null) {
        this.localStorage = new require('node-localstorage').LocalStorage('./conf/');
      }
      else {
        this.localStorage = localStorage;
      }
    }
    else {
      this.localStorage = app.localStorage;
    }

    // Init some local objects
    this.UpdateNodeStatusTimer = {};
    this.LXCHosts = new LXCHosts();
    this.Settings = {};

    // Load settings from localStorage
    this.Settings["known_hosts"] = this.localStorage.getItem('known_hosts', {
      "rpi2-clm.ad.ghanima.net": {}
    });

    // If "known_hosts" was loaded from localStorage it will be a string, not an
    //  array.
    if ((typeof this.Settings["known_hosts"]) == "string") {
      this.Settings["known_hosts"] = JSON.parse(this.Settings["known_hosts"]);
    }

    // Turn the array of "known_hosts" into actual LXCHost objects.
    for (var index in this.Settings["known_hosts"]) {
      console.log(typeof this.Settings["known_hosts"])
      var ThisHost = this.Settings["known_hosts"][index];
      var NewHost = new LXCHost(index)
      //TODO: Set NewHost's properties
      this.LXCHosts.add(NewHost);
    }

    // Start the background workers
    this.UpdateNodeStatusTimer = setInterval((function() {
      this.StartUpdateNodeStatus();
    }).bind(this), 5000);
  }

  // Graceful shutdown handler
  graceful_shutdown(options, err) {
    // Stop updating node status
    clearInterval(this.UpdateNodeStatusTimer);

    // Save settings to disk.
    for (let index in this.Settings) {
      this.localStorage.setItem(index, this.Settings[index]);
    }
    console.log("LXDManagementServer shut down.");
  }

  // Define class functions
  StartUpdateNodeStatus() {
    console.log("Checking status of LXD hosts...");
    console.log(this.LXCHosts);
    for (let host of this.LXCHosts) {
      console.log(host);
      host.IcmpPing();
    }
  }
}

module.exports = LXDManagementServer;
