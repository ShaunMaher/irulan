"use strict";
var fs = require("fs");
var path = require("path");

var LocalStorage = class {
  constructor() {
    // We want as much chance as possible to catch the calling module and 10
    //  lines (the default) might not be enough.
    Error.stackTraceLimit = 50;

    // Load the localStorage module if there isn't one built in.
    if (typeof localStorage === "undefined" || localStorage === null) {
      var localStorage = new require('node-localstorage').LocalStorage('./conf/');
    }
    this.localStorage = localStorage;

    // The script that creates an instance of this object is assumed to be the
    //  one that does NOT have a module name prefixed to the key names.
    this.rootCaller = this._callingFile();
  }

  getItem(key, defaultValue) {
    // Simple hand off to the real setItem function with one slight addition, if
    //  the real getItem returns null, return the provided defaultValue back to
    //  the caller.

    let callingModulePrefix = this._callingModulePrefix();
    //console.log("getItem: callingModulePrefix: " + callingModulePrefix);

    if (this.localStorage.getItem(callingModulePrefix + key) === null) {
      return defaultValue;
    }
    else {
      return this.localStorage.getItem(callingModulePrefix + key);
    }
  }

  setItem(key, value) {
    // Simple hand off to the real setItem function with one slight addition, if
    //  the passed "value" is an object, JSON.stringify it first.

    let callingModulePrefix = this._callingModulePrefix();
    //console.log("setItem: callingModulePrefix: " + callingModulePrefix);
    if ((typeof value) == "object") {
      value = JSON.stringify(value);
    }
    return this.localStorage.setItem(callingModulePrefix + key, value);
  }

  _callingFile() {
    // To get the name of the file and from there the "module" name, we throw an
    //  error and then parse the stack trace attached to the Error object.  We
    //  ignore any steps that are references to ourselves and "module.js" and
    //  assume the first remaining hit is the file the call came from.
    try {
      throw new Error();
    }
    catch (e) {
      for (let line of e.stack.split('\n')) {
        let traceFileName = this._traceFileName(line);
        if (traceFileName) {
          if (traceFileName !== null) {
            if (traceFileName != __filename) {
              if (!traceFileName.match(/module\.js/)) {
                return traceFileName;
              }
            }
          }
        }
      }
      return '';
    }
  }

  _traceFileName(line) {
    // Parse out just the file name on a line of stack dump.
    let callingFileName = (line.split(/\(/))[1];
    if (callingFileName) {
      callingFileName = (callingFileName.split(/\)/))[0];
      if (callingFileName) {
        callingFileName = (callingFileName.split(/:/))[0];
        return callingFileName;
      }
    }
    return null;
  }

  _callingModule(filename) {
    // The parent directory of the calling file is assumed to be the "module"
    //  name.
    let callingModule = '';
    let callingFile = '';
    if (filename !== null) {
      callingFile = this._callingFile();
    }
    return callingModule = path.basename(path.dirname(callingFile));
  }

  _callingModulePrefix() {
    // If the calling file wasn't the script file that created this object (see
    //  earlier note), then the prefix will be the module name and a dot.
    let modulePrefix = '';
    let callingFile = this._callingFile();
    let callingModule = this._callingModule(callingFile);

    if (callingFile != this.rootCaller) {
      return callingModule + ".";
    }
    else {
      return '';
    }
  }
}

module.exports = new LocalStorage();
